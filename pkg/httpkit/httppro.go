package httpkit

import (
	"encoding/xml"
	"errors"
	"fmt"
	"net/http"
	"net/url"
)

// ProblemDetailUntyped is the default value for ProblemDetail.Type.
// When using this value, ProblemDetail.Title will be set to http.StatusText(code).
const ProblemDetailUntyped = "about:blank"

var (
	errProblemDetailTypeEmpty     = errors.New("problem detail type is empty")
	errProblemDetailStatusInvalid = errors.New("problem detail status is invalid")
	errProblemDetailInstanceEmpty = errors.New("problem detail instance is empty")
	errProblemDetailTitleEmpty    = errors.New("problem detail title is empty")
	errProblemDetailDetailEmpty   = errors.New("problem detail detail is empty")
)

// Set of validation levels for ProblemDetail.
const (
	// ProbVLDisabled disables validation.
	ProbVLDisabled uint8 = 0

	// ProbVLRequiredOnly validates only required fields (Type, Title, Status).
	ProbVLRequiredOnly uint8 = 1 << iota

	// ProbVLTypeFormat validates the format of Type to be a valid URI.
	ProbVLTypeFormat

	// ProbVLInstanceFormat validates the format of Instance to be a valid URI path.
	ProbVLInstanceFormat

	// ProbVLDetailRequired validates Detail to be non-empty.
	ProbVLDetailRequired

	// ProbVLInstanceRequired validates Instance to be non-empty.
	ProbVLInstanceRequired

	// ProbVLStrictRequiredOnly validates only required fields (Type, Title, Status) presence and format.
	ProbVLStrictRequiredOnly = ProbVLRequiredOnly | ProbVLTypeFormat

	// ProbVLStrict validates all fields presence and format.
	ProbVLStrict = ProbVLStrictRequiredOnly | ProbVLInstanceFormat | ProbVLDetailRequired | ProbVLInstanceRequired
)

// ProblemDetail is a problem detail as defined in RFC 7807.
// ref: https://tools.ietf.org/html/rfc7807
type ProblemDetail struct {
	XMLName xml.Name `json:"-" xml:"urn:ietf:rfc:7807 problem"`

	// Type is a URI reference [RFC3986] that identifies the problem type.
	// This specification encourages that, when dereferenced, it provides human-readable documentation for the problem
	// type (e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
	// "about:blank".
	//
	// ref: https://tools.ietf.org/html/rfc7807#section-3.1
	Type string `json:"type" xml:"type"`

	// Title A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to occurrence of
	// the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231],
	// Section 3.4).
	//
	// ref: https://tools.ietf.org/html/rfc7807#section-3.1
	Title string `json:"title" xml:"title"`

	// Status The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the
	// problem.
	//
	// ref: https://tools.ietf.org/html/rfc7807#section-3.1
	Status int `json:"status" xml:"status"`

	// Detail (optional) is a human-readable explanation specific to this occurrence of the problem.
	//
	// ref: https://tools.ietf.org/html/rfc7807#section-3.1
	Detail string `json:"detail,omitempty" xml:"detail,omitempty"`

	// Instance (optional) is a URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	//
	// ref: https://tools.ietf.org/html/rfc7807#section-3.1
	Instance string `json:"instance,omitempty" xml:"instance,omitempty"`

	// validateLevel is the level of validation to perform. Defaults to ProbVLStrict.
	validateLevel uint8
}

// NewProblemDetail creates a new ProblemDetail with the given type and options.
// To see the list of available options, see ProbOption namespace.
func NewProblemDetail(typ string, opts ...ProbOption) *ProblemDetail {
	pd := ProblemDetail{
		Type:          typ,
		validateLevel: ProbVLStrict,
	}

	for _, opt := range opts {
		opt(&pd)
	}

	return &pd
}

func (p *ProblemDetail) __mustProblemDetail(*ProblemDetail) {}

// WriteStatus writes the status code to ProblemDetail.Status and updates ProblemDetail.Title if ProblemDetail.Type is
// ProblemDetailUntyped.
func (p *ProblemDetail) WriteStatus(code int) {
	p.Status = code
	if p.Type == ProblemDetailUntyped {
		p.Title = http.StatusText(code)
	}
}

// Validate validates the problem detail based on the validate level.
func (p *ProblemDetail) Validate() (err error) {
	if p.validateLevel != ProbVLDisabled {
		err = errors.Join(
			p.validateType(),
			p.validateStatus(),
			p.validateTitle(),
			p.validateInstance(),
			p.validateDetail(),
		)
	}
	return
}

func (p *ProblemDetail) validateType() error {
	if p.validateLevel&ProbVLRequiredOnly != 0 {
		if p.Type == "" {
			return errProblemDetailTypeEmpty
		}
	}

	if p.validateLevel&ProbVLTypeFormat != 0 {
		_, err := url.ParseRequestURI(p.Type)
		if err != nil {
			return fmt.Errorf("type is not a valid URI: %w", err)
		}
	}
	return nil
}

func (p *ProblemDetail) validateInstance() error {
	if p.validateLevel&ProbVLInstanceRequired != 0 {
		if p.Instance == "" {
			return errProblemDetailInstanceEmpty
		}
	}

	if p.validateLevel&ProbVLInstanceFormat != 0 {
		if _, err := url.Parse(p.Instance); err != nil {
			return fmt.Errorf("instance is not a valid URI path: %w", err)
		}
	}

	return nil
}

func (p *ProblemDetail) validateStatus() error {
	if p.validateLevel&ProbVLRequiredOnly != 0 {
		if p.Status <= 0 || p.Status >= 600 {
			return errProblemDetailStatusInvalid
		}
	}
	return nil
}

func (p *ProblemDetail) validateDetail() error {
	if p.validateLevel&ProbVLDetailRequired != 0 {
		if p.Detail == "" {
			return errProblemDetailDetailEmpty
		}
	}
	return nil
}

func (p *ProblemDetail) validateTitle() error {
	if p.validateLevel&ProbVLRequiredOnly != 0 {
		if p.Title == "" {
			return errProblemDetailTitleEmpty
		}
	}
	return nil
}

// ProblemDetailer is contract for ProblemDetail, this interface is to make ProblemDetail extension possible by using
// struct embedding.
type ProblemDetailer interface {
	// Validate validates the problem detail based on the validate level.
	// Defaults to ProbVLStrict.
	Validate() error

	// WriteStatus writes the status code to ProblemDetail.Status and updates ProblemDetail.Title if ProblemDetail.Type is
	// ProblemDetailUntyped.
	WriteStatus(code int)

	// __mustProblemDetail is a private method to make the Validate and WriteStatus unique to ProblemDetail. Since
	// they are a common method names, it's possible to have a type that implements both methods but not
	// ProblemDetailer.
	__mustProblemDetail(*ProblemDetail)
}

// probNamespace is type for grouping problem detail options.
type probNamespace uint

// ProbOpts is the namespace for accessing the Option for customizing the ProblemDetail.
const ProbOpts probNamespace = 0

// ProbOption is the type for customizing the ProblemDetail.
type ProbOption func(*ProblemDetail)

// ValidateLevel sets the validation level for ProblemDetail.
func (probNamespace) ValidateLevel(v uint8) ProbOption {
	return func(pd *ProblemDetail) { pd.validateLevel = v }
}

// Instance sets the instance for ProblemDetail.
func (probNamespace) Instance(v string) ProbOption {
	return func(pd *ProblemDetail) { pd.Instance = v }
}

// Detail sets the detail for ProblemDetail.
func (probNamespace) Detail(v string) ProbOption {
	return func(pd *ProblemDetail) { pd.Detail = v }
}

// Title sets the title for ProblemDetail.
func (probNamespace) Title(v string) ProbOption {
	return func(pd *ProblemDetail) { pd.Title = v }
}
